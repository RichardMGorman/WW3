#include "w3macros.h"
!/ ------------------------------------------------------------------- /
      MODULE W3PROQMD
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           H. L. Tolman            |
!/                  | QUADTREE version             NIWA |
!/                  |           R. M. Gorman            |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         29-May-2014 |
!/                  +-----------------------------------+
!/
!/    13-May-2008 : Origination (R. Gorman)
!/    20-Oct-2009 : Bringing into line with WAVEWATCH III v3.14
!/    20-May-2014 : Bringing into line with WAVEWATCH III v4.18qa
!/
!/
!/    Copyright 2009 National Weather Service (NWS),
!/       National Oceanic and Atmospheric Administration.  All rights
!/       reserved.  WAVEWATCH III is a trademark of the NWS. 
!/       No unauthorized use without permission.
!/
!  1. Purpose :
!
!     Spatial propagation on quadtee grids
!
!  2. Variables and types :
!
!      Name      Type  Scope    Description
!     ----------------------------------------------------------------
!     ----------------------------------------------------------------
!
!  3. Subroutines and functions :
!
!      Name      Type  Scope    Description
!     ----------------------------------------------------------------
!      W3XYQ1    Subr. Public   First order spatial propagation.
!      W3MPQ1    Subr. Public   Compute ranges of refinement levels.
!     ----------------------------------------------------------------
!
!  4. Subroutines and functions used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!     QA_TSORDER Subr. qa_utils Compute order of levels in substepping
!     ----------------------------------------------------------------
!
!  5. Remarks :
!
!  6. Switches :
!
!  7. Source code :
!/
!/ ------------------------------------------------------------------- /
!/
!     
      PUBLIC
!/
      CONTAINS
!/ ------------------------------------------------------------------- /
      SUBROUTINE W3XYQ1 ( ISP, DTG, MAPSTA, FIELD, VGX, VGY, LVRANGE )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH-III           NOAA/NCEP |
!/                  |           H. L. Tolman            |
!/                  | QUADTREE version             NIWA |
!/                  |           R. M. Gorman            |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         27-May-2014 |
!/                  +-----------------------------------+
!/
!/    13-Dec-1999 : Origination.
!/    13-May-2008 : Inclusion of new code (R. Gorman)
!/    20-Oct-2009 : Bringing into line with WAVEWATCH III v4.18qa
!/
!  1. Purpose :
!
!     Propagation in physical space for a given spectral component,
!     on a quadtree grid. 
!
!  2. Method :
!
!     First order scheme with flux formulation.
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       ISP     Int.   I   Number of spectral bin (IK-1)*NTH+ITH
!       DTG     Real   I   Total time step.
!       MAPSTA  I.A.   I   Grid point status map.
!       FIELD   R.A.  I/O  Wave action spectral densities on full
!                          grid.
!       VGX/Y   Real   I   Speed of grid.
!       LVRANGE I.A.   I   For each cell, gives the minimum and maximum
!                          refinement level of the cell and its immediate
!                          neighbours
!     ----------------------------------------------------------------
!
!     Local variables.
!     ----------------------------------------------------------------
!       NTLOC   Int.  Number of local steps.
!       VCX     R.A.  Propagation velocities.
!       VCY     R.A.
!       VFLX    R.A.  Discrete fluxes between grid points.
!       VFLY    R.A.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!      Name      Type  Module   Description
!     ---------------------------------------------------------------- 
!      W3WAVE    Subr. W3WAVEMD Wave model routine.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!       None.
!
!  7. Remarks :
!
!     - The local work arrays are initialized on the first entry to
!       the routine.
!
!  8. Structure :
!
!     ---------------------------------------
!       1.  Preparations
!         a Set constants
!         b Initialize arrays
!       2.  Calculate local discrete fluxes
!       3.  Calculate propagation fluxes
!       4.  Propagate
!       5.  Update boundary conditions
!     ---------------------------------------
!
!  9. Switches :
!
!     !/S   Enable subroutine tracing.
!
!     !/T   Enable general test output.
!     !/T1  Test output local fluxes (V)FX-YL.
!     !/T2  Test output propagation fluxes (V)FLX-Y.
!     !/T3  Test output propagation.
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
      USE CONSTANTS
      USE QA_UTILS
!
      USE W3TIMEMD, ONLY: DSEC21
!
      USE W3GDATMD, ONLY: NK, NTH, SIG, ECOS, ESIN, NSEA, MAPSF,      &
                          DTCFL, CLATS, IQGW, QTREE, FLAGLL, FLCX,    &
                          FLCY, SX, SY
      USE W3WDATMD, ONLY: TIME
      USE W3ADATMD, ONLY: CG, CX, CY, ATRNX, ATRNY
      USE W3IDATMD, ONLY: FLCUR
      USE W3ODATMD, ONLY: NDST, FLBPI, NBI, TBPI0, TBPIN, ISBPI,      &
                          BBPI0, BBPIN
!/S      USE W3SERVMD, ONLY: STRACE
!/
      IMPLICIT NONE
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      INTEGER, INTENT(IN)     :: ISP, MAPSTA(NSEA)
      REAL, INTENT(IN)        :: DTG, VGX, VGY
      REAL, INTENT(INOUT)     :: FIELD(0:NSEA+2)
      INTEGER, INTENT(IN)     :: LVRANGE(NSEA,2)
!/
!/ ------------------------------------------------------------------ /
!/ Local parameters
!/
      INTEGER                 :: IK, ITH, NTLOC, ITLOC, ISEA, NTSUB, &
                                 ITSUB, JXN, JXP, JYN, JYP, IBI,     &
                                 INBRX1, INBRX2, INBRY1, INBRY2, IXY
      INTEGER                 :: LVLR, LVLT, LVLM, LVLCALC, LVL1,    &
                                 LVL2, LVL
!/T3      INTEGER                 :: IX, IXF, IYF
!/S      INTEGER, SAVE           :: IENT = 0
      REAL                    :: CG0, CGL, CGA, CC, CGN, CP, CQ
      REAL                    :: VCB
      REAL                    :: RD1, RD2, DXYFAC, DTLOC, DTRAD
      REAL                    :: FNBR
      REAL                    :: TRAT, TSUBFAC
!/T3      REAL                    :: AOLD
!/
!/ Automatic work arrays
!/
      REAL                    :: CXTOT(NSEA), CYTOT(NSEA)
      REAL                    :: VCX(NSEA), VCY(NSEA),               &
                                 VFLW(NSEA), VFLE(NSEA),             &
                                 VFLS(NSEA), VFLN(NSEA)
      INTEGER, ALLOCATABLE    :: LVLSTEP(:)
!/
!/ ------------------------------------------------------------------- /
!/
!/S      CALL STRACE (IENT, 'W3XYQ1')
!
! 1.  Preparations --------------------------------------------------- *
! 1.a Set constants
!
      ITH    = 1 + MOD(ISP-1,NTH)
      IK     = 1 + (ISP-1)/NTH
!
      CG0    = 0.575 * GRAV / SIG(1)
      CGL    = 0.575 * GRAV / SIG(IK)
!
      IF ( FLCUR ) THEN
          CGA    = SQRT(MAXVAL((CGL*ECOS(ITH)+CX(1:NSEA))**2          &
                              +(CGL*ESIN(ITH)+CY(1:NSEA))**2))
          CC     = SQRT(MAXVAL(CX(1:NSEA)**2+CY(1:NSEA)**2))
!/MGP          CGA    = SQRT(MAXVAL((CGL*ECOS(ITH)+CX(1:NSEA)-VGX)**2      &
!/MGP                              +(CGL*ESIN(ITH)+CY(1:NSEA)-VGY)**2))
!/MGP          CC     = SQRT(MAXVAL((CX(1:NSEA)-VGX)**2+(CY(1:NSEA)-VGY)**2))
        ELSE
          CGA    = CGL
!/MGP          CGA    = SQRT((CGL*ECOS(ITH)-VGX)**2+(CGL*ESIN(ITH)-VGY)**2)
          CC     = 0.
        END IF
!
      CGN    = 0.9999 * MAX ( CGA, CC, 0.001*CG0 )
!
! 1.b Universal time stepping
!
      TRAT = DTG/(DTCFL*CG0/CGN)
      NTLOC  = 1 + INT(TRAT)
      DTLOC  = DTG / REAL(NTLOC)
      DTRAD  = DTLOC
      IF ( FLAGLL ) DTRAD=DTRAD/(DERA*RADIUS)

!
!/T      WRITE (NDST,9000) NTLOC
!/T      WRITE (NDST,9001) ISP, ITH, IK
!
! 1.c Level-dependent time substepping
!      In each universal time step, cells with level 0 to LVLT will be 
!       updated once, while cells with level L > LVLT will
!       be updated 2**(L - LVLT) times.
!      That makes a total number of substeps
!        NTSUB = 1 + 2 + ... + 2**(LVLMAX-LVLT) = 2**(LVLM-LVLT+1) - 1
!      First determine LVLT, so that one step at that level won't exceed 
!      the CFL time step (which applies at the reference level).
!      Then call QA_TSORDER to compute the sequence of levels calculated 
!      at each substep
!
      LVLR = QTREE(IQGW)%LVLREF
      LVLM = QTREE(IQGW)%LVLHI
      LVLT = LVLR
      !LVLT = LVLM   ! Turn off substepping
      DO WHILE ( TRAT.LT.1. .AND. LVLT.LE.LVLM )
         TRAT = 2.*TRAT
         IF ( TRAT.LT.1. ) LVLT = LVLT + 1
      END DO
      NTSUB = 2**(LVLM-LVLT+1) - 1
      ALLOCATE ( LVLSTEP(NTSUB) )
      CALL QA_TSORDER( NTSUB, LVLM, LVLT, LVLSTEP, iopt=1 )
!
!/T      WRITE (NDST,9002) LVLT, NTSUB
!
! 1.d Initialize arrays
!
      VCX   = 0.
      VCY   = 0.
      CXTOT  = 0.
      CYTOT  = 0.
!
! 2.  Calculate field and velocities --------------------------------- *
!
!     FIELD = A / CG * CLATQ
!     VCX   = COS*CG / CLATQ
!     VCY   = SIN*CG
!
!/T1      WRITE (NDST,9020)
!     Propagation velocity components (relative to water):
      DO ISEA=1, NSEA
        IXY = MAPSF(ISEA,3)
        IF ( MAPSTA(IXY).EQ.0 ) CYCLE
        FIELD(IXY) = FIELD(IXY) / CG(IK,ISEA) * CLATS(ISEA)
        CXTOT(IXY) = ECOS(ITH) * CG(IK,ISEA) / CLATS(ISEA)
        CYTOT(IXY) = ESIN(ITH) * CG(IK,ISEA)
!/MGP        CXTOT(IXY) = CXTOT(IXY) - VGX/CLATS(ISEA)
!/MGP        CXTOT(IXY) = CYTOT(IXY) - VGY
!/T1          WRITE (NDST,9021) ISEA, IXY, FIELD(IXY), CXTOT(IXY), CYTOT(IXY)
      END DO
      FIELD(0) = 0.
!
!     Propagation velocity components (adjusted for currents):
      IF ( FLCUR ) THEN
         DO ISEA=1, NSEA
           IXY      = MAPSF(ISEA,3)
           IF ( MAPSTA(IXY).EQ.0 ) CYCLE
           CXTOT(IXY) = CXTOT(IXY) + CX(ISEA)/CLATS(ISEA)
           CYTOT(IXY) = CYTOT(IXY) + CY(ISEA)
         END DO
      END IF
!
!     Multiply x- component by dT/dX(m)          
      IF ( FLCX ) THEN
         DO ISEA=1, NSEA
           IXY    = MAPSF(ISEA,3)
           IF ( MAPSTA(IXY).EQ.0 ) CYCLE
           CP = CXTOT(IXY)/SX
           VCX(IXY) = CP*DTRAD
         END DO
      ELSE
          VCX = 0.0
      ENDIF
!     Multiply y- component by dT/dY(m)          
      IF ( FLCY ) THEN
         DO ISEA=1, NSEA
            IXY    = MAPSF(ISEA,3)
!            CQ = CXTOT(IXY)/SX
            CQ = CXTOT(IXY)/SY
            VCY(IXY) = CQ*DTRAD
         END DO
      ELSE
         VCY = 0.0
      ENDIF
!
! ====================== Loop partial ================================ *
!     Applies to all cells
!
      DO ITLOC=1, NTLOC
!
!       Time substep loop
!      
        DO ITSUB=1, NTSUB
          ! Level of cells processed at this iteration of the substep loop:
          ! (if LVCALC = LVLT, all levels <= LVLT are processed)
          LVLCALC = LVLSTEP(ITSUB)
          ! Time step for this iteration, as a fraction of the universal 
          ! partial time step
          TSUBFAC = 2.**(LVLT-LVLCALC)
!
!/T1        WRITE (NDST,9010) ITLOC
!
! 3.  Calculate propagation fluxes ----------------------------------- *
!     Only for boundaries of cells that will be updated
!
          DO ISEA=1,NSEA
            IXY = MAPSF(ISEA,3)
            IF ( MAPSTA(IXY).EQ.0 ) CYCLE
            LVL1 = MAX(LVRANGE(ISEA,1),LVLT)
            LVL2 = MAX(LVRANGE(ISEA,2),LVLT)
            IF ( LVLCALC.LT.LVL1 .OR. LVLCALC.GT.LVL2 ) CYCLE
            ! Flux through the east wall:
            INBRX1 = QTREE(IQGW)%NGBR(ISEA,2)
            INBRX2 = QTREE(IQGW)%NGBR(ISEA,6)
            IF ( INBRX1 .GT. 0 .AND. INBRX2 .GT. 0 ) THEN
              VCB  = ( VCX(ISEA) + VCX(INBRX1) + VCX(INBRX2) )/3.
              FNBR = 0.5*( FIELD(INBRX1) + FIELD(INBRX2) )
            ELSEIF ( INBRX1 .GT. 0 ) THEN
              VCB  = ( VCX(ISEA) + VCX(INBRX1) )*0.5
              FNBR = FIELD(INBRX1)
            ELSE
              VCB  = VCX(ISEA)
              FNBR = 0.
            END IF
            VFLE(ISEA) = MAX ( VCB , 0. ) * FIELD(ISEA)               &
                       + MIN ( VCB , 0. ) * FNBR
            ! Flux through the west wall:
            INBRX1 = QTREE(IQGW)%NGBR(ISEA,1)
            INBRX2 = QTREE(IQGW)%NGBR(ISEA,5)
            IF ( INBRX1 .GT. 0 .AND. INBRX2 .GT. 0 ) THEN
              VCB  = ( VCX(ISEA) + VCX(INBRX1) + VCX(INBRX2) )/3.
              FNBR = 0.5*( FIELD(INBRX1) + FIELD(INBRX2) )
            ELSEIF ( INBRX1 .GT. 0 ) THEN
              VCB  = ( VCX(ISEA) + VCX(INBRX1) )*0.5
              FNBR = FIELD(INBRX1)
            ELSE
              VCB  = VCX(ISEA)
              FNBR = 0.
            END IF
            VFLW(ISEA) = MIN ( VCB , 0. ) * FIELD(ISEA)               &
                       + MAX ( VCB , 0. ) * FNBR
            ! Flux through the north wall:
            INBRY1 = QTREE(IQGW)%NGBR(ISEA,4)
            INBRY2 = QTREE(IQGW)%NGBR(ISEA,8)
            IF ( INBRY1 .GT. 0 .AND. INBRY2 .GT. 0 ) THEN
              VCB  = ( VCY(ISEA) + VCY(INBRY1) + VCY(INBRY2) )/3.
              FNBR = 0.5*( FIELD(INBRY1) + FIELD(INBRY2) )
            ELSEIF ( INBRY1 .GT. 0 ) THEN
              VCB  = ( VCY(ISEA) + VCY(INBRY1) )*0.5
              FNBR = FIELD(INBRY1)
            ELSE
              VCB  = VCY(ISEA)
              FNBR = 0.
            END IF
            VFLN(ISEA) = MAX ( VCB , 0. ) * FIELD(ISEA)               &
                       + MIN ( VCB , 0. ) * FNBR
            ! Flux through the south wall:
            INBRY1 = QTREE(IQGW)%NGBR(ISEA,3)
            INBRY2 = QTREE(IQGW)%NGBR(ISEA,7)
            IF ( INBRY1 .GT. 0 .AND. INBRY2 .GT. 0 ) THEN
              VCB  = ( VCY(ISEA) + VCY(INBRY1) + VCY(INBRY2) )/3.
              FNBR = 0.5*( FIELD(INBRY1) + FIELD(INBRY2) )
            ELSEIF ( INBRY1 .GT. 0 ) THEN
              VCB  = ( VCY(ISEA) + VCY(INBRY1) )*0.5
              FNBR = FIELD(INBRY1)
            ELSE
              VCB  = VCY(ISEA)
              FNBR = 0.
            END IF
            VFLS(ISEA) = MIN ( VCB , 0. ) * FIELD(ISEA)               &
                       + MAX ( VCB , 0. ) * FNBR
          END DO
!
!
! 4.  Propagate ------------------------------------------------------ *
!
!/T3          WRITE (NDST,9040)
!/C90/!DIR$ IVDEP
          DO ISEA=1, NSEA
!
!/T3            AOLD   = FIELD(ISEA) * CG(IK,ISEA) / CLATQ(ISEA)
!
            IXY = MAPSF(ISEA,3)
            IF ( MAPSTA(IXY).EQ.0 ) CYCLE
            LVL = QTREE(IQGW)%INDLVL(ISEA)
            ! Inverse ratio of cell DX and DY to those at the reference level
            DXYFAC = 2.**(LVL-LVLR)
            LVL = MAX(LVL,LVLT)
            IF ( LVL.NE.LVLCALC ) CYCLE
            IF ( MAPSTA(IXY).EQ.1 ) THEN
!
              IF ( VFLW(ISEA) .GT. 0. ) THEN
                JXN   = -1
              ELSE
                JXN   =  0
              END IF
              IF ( VFLE(ISEA  ) .LT. 0. ) THEN
                JXP   =  1
              ELSE
                JXP   =  0
              END IF
              IF ( VFLS(ISEA) .GT. 0. ) THEN
                JYN   = -1
              ELSE
                JYN   =  0
              END IF
              IF ( VFLN(ISEA  ) .LT. 0. ) THEN
                JYP   =  1
              ELSE
                JYP   =  0
              END IF
!
              FIELD(ISEA) =  FIELD(ISEA)                              &
                     + DXYFAC*TSUBFAC*( ATRNX(ISEA,JXN) * VFLW(ISEA)  &
                                      - ATRNX(ISEA,JXP) * VFLE(ISEA)  &
                                      + ATRNY(ISEA,JYN) * VFLS(ISEA)  &
                                      - ATRNY(ISEA,JYP) * VFLN(ISEA) )
!/T3              WRITE (NDST,9041) ISEA,                                 &
!/T3                 (QTREE(IQGW)%NGBR(ISEA,II),II=1,4),                  &
!/T3                 VFLW(ISEA), VFLE(ISEA),                              &
!/T3                 VFLS(ISEA), VFLN(ISEA),                              &
!/T3                 CG(IK,ISEA)/CLATQ(ISEA), AOLD, FIELD(ISEA)
!
            ELSEIF (MAPSTA(IXY).NE.0) THEN
!
!/T3              WRITE (NDST,9042) ISEA, MAPSTA(IXY), AOLD, FIELD(ISEA)
!
            END IF
!
          END DO
!
! 5.  Update boundary conditions ------------------------------------- *
!
          IF ( FLBPI ) THEN
            RD1    = DSEC21 ( TBPI0, TIME ) - DTG *                   &
                                   REAL(NTLOC - ITLOC)/REAL(NTLOC)
            RD2    = DSEC21 ( TBPI0, TBPIN )
            IF ( RD2 .GT. 0.001 ) THEN
              RD2    = MIN(1.,MAX(0.,RD1/RD2))
              RD1    = 1. - RD2
            ELSE
              RD1    = 0.
              RD2    = 1.
            END IF
            DO IBI=1, NBI
              ISEA = ISBPI(IBI)
              FIELD(ISEA) = ( RD1*BBPI0(ISP,IBI) +                    &
                       RD2*BBPIN(ISP,IBI) ) * CLATS(ISEA)/CG(IK,ISEA)
            END DO
          END IF
!
! ... End of partial time substep loop
!
        END DO
!
! ... End of partial time step loop
!
      END DO
!
! Rescale FIELD
!
      DO ISEA=1,NSEA
        IXY = MAPSF(ISEA,3)
        IF ( MAPSTA(IXY).EQ.0 ) CYCLE
        FIELD(ISEA) = CG(IK,ISEA) / CLATS(ISEA) * FIELD(ISEA)
      END DO
!
      RETURN
!
! Formats
!
!/T 9000 FORMAT (' TEST W3XYQ1 : NTLOC :',I4)
!/T 9001 FORMAT (' TEST W3XYQ1 : ISP, ITH, IK :',I8,2I4)
!/T 9002 FORMAT (' TEST W3XYQ1 : LVLT, NTSUB :',2I4)
!
!/T1 9010 FORMAT (' TEST W3XYQ1 : ITLOC =',I3)
!
!/T1 9020 FORMAT (' TEST W3XYQ1 : ISEA, IXY, FIELD, VCX, VCY')
!/T1 9021 FORMAT ('           ',2I8,3E12.4)
!/T1 9025 FORMAT ('               ',I4,2E12.4)
!
!/T2 9032 FORMAT (' TEST W3XYQ1 : CLOSE. : IY, VFLX')
!/T2 9033 FORMAT ('            ',I4,E12.4)
!
!/T3 9040 FORMAT (' TEST W3XYQ1 : PROPAGATION '/                      &
!/T3              '      ISEA, ISEAW, ISEAE, ISEAS, ISEAN',           &
!/T3              '  FLXW, FLXE, FLXS, FLXN, FAC, A(2)')
!/T3 9041 FORMAT (2X,5I5,1X,4E10.3,1X,E10.3,1X,2E10.3)
!/T3 9042 FORMAT (2X,I5,'( MAP = ',I2,' )',56X,2E10.3)
!/
!/
!/ End of W3XYQ1 ----------------------------------------------------- /
!/
      END SUBROUTINE W3XYQ1
!      
!/ ------------------------------------------------------------------- /
      SUBROUTINE W3XYQ2 ( ISP, DTG, FIELD, VGX, VGY )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH-III           NOAA/NCEP |
!/                  |           H. L. Tolman            |
!/                  | QUADTREE version             NIWA |
!/                  |           R. M. Gorman            |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         17-Oct-2017 |
!/                  +-----------------------------------+
!/
!/    17-Oct-2017 : Origination, based on W3XYQ1 and W3PSMC
!/
!  1. Purpose :
!
!     Propagation in physical space for a given spectral component,
!     on a quadtree grid. 
!
!  2. Method :
!
!     Second order UNO2 scheme with flux formulation.
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       ISP     Int.   I   Number of spectral bin (IK-1)*NTH+ITH
!       DTG     Real   I   Total time step.
!       FIELD   R.A.  I/O  Wave action spectral densities on full
!                          grid.
!       VGX/Y   Real   I   Speed of grid.
!     ----------------------------------------------------------------
!
!     Local variables.
!     ----------------------------------------------------------------
!       NTLOC   Int.  Number of local steps.
!       VCX     R.A.  Propagation velocities.
!       VCY     R.A.
!       VFLX    R.A.  Discrete fluxes between grid points.
!       VFLY    R.A.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!      Name      Type  Module   Description
!     ---------------------------------------------------------------- 
!      W3WAVE    Subr. W3WAVEMD Wave model routine.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!       None.
!
!  7. Remarks :
!
!     - The local work arrays are initialized on the first entry to
!       the routine.
!
!  8. Structure :
!
!     ---------------------------------------
!       1.  Preparations
!         a Set constants
!         b Initialize arrays
!       2.  Calculate local discrete fluxes
!       3.  Calculate propagation fluxes
!       4.  Propagate
!       5.  Update boundary conditions
!     ---------------------------------------
!
!  9. Switches :
!
!     !/S   Enable subroutine tracing.
!
!     !/T   Enable general test output.
!     !/T1  Test output local fluxes (V)FX-YL.
!     !/T2  Test output propagation fluxes (V)FLX-Y.
!     !/T3  Test output propagation.
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
      USE CONSTANTS
      USE QA_UTILS
!
      USE W3TIMEMD, ONLY: DSEC21
!
      USE W3GDATMD, ONLY: NTH, SIG, ECOS, ESIN, NSEA,                  &
                          DTCFL, CLATS, IQGW, QTREE, FLAGLL, FLCX,     &
                          FLCY, SX, SY, DTH, XFR, DTCFL, DTME,         &
                          IJKCel, IJKUFc, IJKVFc, NLvUFc, NLvVFc,      &
                          NUFc, NVFc
      USE W3WDATMD, ONLY: TIME
      USE W3ADATMD, ONLY: CG, CX, CY, ATRNX, ATRNY
      USE W3IDATMD, ONLY: FLCUR
      USE W3ODATMD, ONLY: NDST, FLBPI, NBI, TBPI0, TBPIN, ISBPI,       &
                          BBPI0, BBPIN
!/S      USE W3SERVMD, ONLY: STRACE
!/
      IMPLICIT NONE
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      INTEGER, INTENT(IN)     :: ISP
      REAL, INTENT(IN)        :: DTG, VGX, VGY
      REAL, INTENT(INOUT)     :: FIELD(0:NSEA+2)
!/
!/ ------------------------------------------------------------------ /
!/ Local parameters
!/
      INTEGER                 :: IK, ITH, NTLOC, ITLOC, ISEA, NTSUB
      INTEGER                 :: ITSUB, IBI, IUF, IVF, JUF, JVF
      INTEGER                 :: IFC, M, N
      INTEGER                 :: LVLR, LVLT, LVLM, LVLCALC, LVL
!/S      INTEGER, SAVE           :: IENT = 0
      REAL                    :: CG0, CGL, CGA, CC, CGN, CGD
      REAL                    :: RD1, RD2, DXYFAC, DTLOC, DTRAD
      REAL                    :: TRAT, TSUBFAC
      REAL                    :: DX0, DY0, DFRR, DNN, FMR
      REAL                    :: TRANS1, TRANS2, FUTRN, FVTRN
      INTEGER                 :: UNDEF
!/
!/ Automatic work arrays
!/
      REAL                    :: CXTOT(NSEA), CYTOT(NSEA)
      REAL                    :: DNND(NSEA), DSSD(NSEA)
      INTEGER, ALLOCATABLE    :: LVLSTEP(:)
      REAL, Dimension(-9:NSEA) ::  FCNt, AFCN, BCNt, UCFL, VCFL, CQ, CQA
      REAL, Dimension(   NUFc) ::  FUMD, FUDIFX, ULCFLX
      REAL, Dimension(   NVFc) ::  FVMD, FVDIFY, VLCFLY
!/
!/ ------------------------------------------------------------------- /
!/
!/S      CALL STRACE (IENT, 'W3XYQ2')
!
! 1.  Preparations --------------------------------------------------- *
! 1.a Set constants
!
      UNDEF = QTREE(IQGW)%UNDEF_TYPE
!
      ITH    = 1 + MOD(ISP-1,NTH)
      IK     = 1 + (ISP-1)/NTH
!
!/T      WRITE (NDST,9001) ISP, ITH, IK
!
      CG0    = 0.575 * GRAV / SIG(1)
      CGL    = 0.575 * GRAV / SIG(IK)
!
      IF ( FLCUR ) THEN
          CGA    = SQRT(MAXVAL((CGL*ECOS(ITH)+CX(1:NSEA))**2          &
                              +(CGL*ESIN(ITH)+CY(1:NSEA))**2))
          CC     = SQRT(MAXVAL(CX(1:NSEA)**2+CY(1:NSEA)**2))
!/MGP          CGA    = SQRT(MAXVAL((CGL*ECOS(ITH)+CX(1:NSEA)-VGX)**2      &
!/MGP                              +(CGL*ESIN(ITH)+CY(1:NSEA)-VGY)**2))
!/MGP          CC     = SQRT(MAXVAL((CX(1:NSEA)-VGX)**2+(CY(1:NSEA)-VGY)**2))
        ELSE
          CGA    = CGL
!/MGP          CGA    = SQRT((CGL*ECOS(ITH)-VGX)**2+(CGL*ESIN(ITH)-VGY)**2)
          CC     = 0.
        END IF
!
      CGN    = 0.9999 * MAX ( CGA, CC, 0.001*CG0 )
!
! 1.b Universal time stepping
!
      TRAT = DTG/(DTCFL*CG0/CGN)
      NTLOC  = 1 + INT(TRAT)
      DTLOC  = DTG / REAL(NTLOC)
      DTRAD  = DTLOC
!
!/T      WRITE (NDST,9000) NTLOC
!
      LVLR = QTREE(IQGW)%LVLREF
      LVLM = QTREE(IQGW)%LVLHI
      LVLT = LVLR
      !LVLT = LVLM   ! Turn off substepping
! 1.c Level-dependent time substepping
!      In each universal time step, cells with level 0 to LVLT will be 
!       updated once, while cells with level L > LVLT will
!       be updated 2**(L - LVLT) times.
!      That makes a total number of substeps
!        NTSUB = 1 + 2 + ... + 2**(LVLMAX-LVLT) = 2**(LVLM-LVLT+1) - 1
!      First determine LVLT, so that one step at that level won't exceed 
!      the CFL time step (which applies at the reference level).
!      Then call QA_TSORDER to compute the sequence of levels calculated 
!      at each substep
      DO WHILE ( TRAT.LT.1. .AND. LVLT.LE.LVLM )
          TRAT = 2.*TRAT
          IF ( TRAT.LT.1. ) LVLT = LVLT + 1
      END DO
      NTSUB = 2**(LVLM-LVLT+1) - 1
!
!/T      WRITE (NDST,9002) LVLT, NTSUB
!
      ALLOCATE ( LVLSTEP(NTSUB) )
      CALL QA_TSORDER( NTSUB, LVLM, LVLT, LVLSTEP, iopt=0 )
!
!     cell grid lengths at Equator (at finest refinement level).
!
      DX0    = SX*2.**(LVLR-LVLM)
      DY0    = SY*2.**(LVLR-LVLM)
      IF ( FLAGLL ) THEN
         DTRAD = DTRAD/(DERA*RADIUS)
         DX0   = DX0 * DERA * RADIUS
         DY0   = DY0 * DERA * RADIUS
      END IF
!
!     Homogenous diffusion coefficient DNN.
      IF ( DTME .GT. 0. ) THEN
          DFRR   = XFR - 1.
          CGD    = 0.5 * GRAV / SIG(IK)
          DNN    = ((DTH*CGD)**2)*DTME / 12.
      END IF

!
! 1.d Initialize arrays
!
      CQ = 0.0
      CQA = 0.0
      CXTOT = 0.0
      CYTOT = 0.0
      AFCN = 0.0
      BCNt = 0.0
      FCNt = 0.0
!
      UCFL = 0.0
      VCFL = 0.0
      DNND = 0.0
      DSSD = 0.0
!
!
! 2.  Calculate field and velocities --------------------------------- *
!
!
!/T1      WRITE (NDST,9020)
!     Propagation velocity components (relative to water):
      DO ISEA=1, NSEA
        IF ( QTREE(IQGW)%CELL_TYPE(ISEA) .EQ. UNDEF ) CYCLE
        CQ(ISEA) = FIELD(ISEA) / CG(IK,ISEA) * CLATS(ISEA)
        CXTOT(ISEA) = ECOS(ITH) * CG(IK,ISEA) / CLATS(ISEA)
        CYTOT(ISEA) = ESIN(ITH) * CG(IK,ISEA)
!
!/MGP        CXTOT(ISEA) = CXTOT(ISEA) - VGX/CLATS(ISEA)
!/MGP        CXTOT(ISEA) = CYTOT(ISEA) - VGY
!/T1          WRITE (NDST,9021) ISEA, ISEA, CQ(ISEA), CXTOT(ISEA), CYTOT(ISEA)
      END DO
!
!     Propagation velocity components (adjusted for currents):
      IF ( FLCUR ) THEN
         DO ISEA=1, NSEA
           IF ( QTREE(IQGW)%CELL_TYPE(ISEA) .EQ. UNDEF ) CYCLE
           IF ( FLCX ) CXTOT(ISEA) = CXTOT(ISEA) + CX(ISEA)/CLATS(ISEA)
           IF ( FLCY ) CYTOT(ISEA) = CYTOT(ISEA) + CY(ISEA)
         END DO
      END IF
!
!     Convert propagation velocities to CFL numbers, using global
!     time substep dT and cell sizes dX, dY at finest refinement
!     Similarly for diffusion coefficients
!     Multiply x- component by dT(s)/dX(m)          
!     Multiply y- component by dT(s)/dY(m)          
!     Multiply diffusion coefficient by dT/dX^2, dT/dY^2
      DO ISEA=1, NSEA
         IF ( QTREE(IQGW)%CELL_TYPE(ISEA) .EQ. UNDEF ) CYCLE
         UCFL(ISEA) = CXTOT(ISEA)*DTRAD/(DX0*CLATS(ISEA))
         VCFL(ISEA) = CYTOT(ISEA)*DTRAD/DY0
         IF ( DTME .GT. 0. ) THEN
            DNND(ISEA) = DNN*DTLOC/(DX0*CLATS(ISEA))**2
            DSSD(ISEA) = DNN*DTLOC/(DY0*DY0)
         END IF
      END DO
!
! ====================== Loop partial ================================ *
!     Applies to all cells
!
      DO ITLOC=1, NTLOC
!
!       Time substep loop
!      
        DO ITSUB=1, NTSUB
           ! Level of cells processed at this iteration of the substep loop:
           ! (if LVCALC = LVLT, all levels <= LVLT are processed)
           LVLCALC = LVLSTEP(ITSUB)
           ! Corresponding range of wall indices, for walls with cells
           ! of that size on either side
           IF ( LVLCALC.GT.LVLT ) THEN
              ! Cells at one refinement level are updated.
              IF (LVLM-LVLCALC.GT.0) THEN
                 IUF = NLvUFc(LVLM-LVLCALC) + 1
                 IVF = NLvVFc(LVLM-LVLCALC) + 1
              ELSE
                 IUF = 1
                 IVF = 1
              END IF
              JUF = NLvUFc(LVLM-LVLCALC+1)
              JVF = NLvVFc(LVLM-LVLCALC+1)
           ELSE
              ! Cells at all refinement levels <= LVLT are updated.
              IF (LVLM-LVLT.GT.0) THEN
                 IUF = NLvUFc(LVLM-LVLT) + 1
                 IVF = NLvVFc(LVLM-LVLT) + 1
              ELSE
                 IUF = 1
                 IVF = 1
              END IF
              JUF = NLvUFc(LVLM+1)
              JVF = NLvVFc(LVLM+1)
           END IF
           ! Time step for this iteration, as a fraction of the universal 
           ! partial time step
           TSUBFAC = 2.**(LVLT-LVLCALC)
           ! Time step for this iteration, as a multiple of the finest
           ! refinement level time step
           FMR = 2.**(LVLM-LVLCALC)
!
!/T1        WRITE (NDST,9010) ITLOC
!
! 3.  Calculate propagation fluxes ----------------------------------- *
!     Only for boundaries of cells that will be updated
!
!     In X dimension
!
           CALL QT1DUNO2( -9, IUF, JUF, IJKUFc(4:7,:), CQ, UCFL,       &
                          IJKCel(3,:), DNND, IJKUFc(3,:), FMR, ULCFLX, &
                          FUMD, FUDIFX )
!
!  Store conservative flux in FCNt advective one in AFCN
!  Add sub-grid transparency for input flux update. 
!  Transparency is also applied on diffusion flux.  
           DO IFC=IUF, JUF 
              M=IJKUFc(5,IFC)
              N=IJKUFc(6,IFC)
              TRANS1 = 1.
              IF ( M.GT.0 ) TRANS1 = ATRNX(M,1)
              TRANS2 = 1.
              IF ( N.GT.0 ) TRANS2 = ATRNX(N,-1)
              IF( ULCFLX(IFC) .GE. 0.0 )  THEN
                 FUTRN = (FUMD(IFC)*ULCFLX(IFC) - FUDIFX(IFC))*TRANS1
                 FCNt(M) = FCNt(M) - FUTRN
                 FCNt(N) = FCNt(N) + FUTRN*TRANS2
              ELSE
                 FUTRN = (FUMD(IFC)*ULCFLX(IFC) - FUDIFX(IFC))*TRANS2
                 FCNt(M) = FCNt(M) - FUTRN*TRANS1
                 FCNt(N) = FCNt(N) + FUTRN 
              ENDIF
              AFCN(M) = AFCN(M) - FUMD(IFC)*UCFL(M)*FMR + FUDIFX(IFC)
              AFCN(N) = AFCN(N) + FUMD(IFC)*UCFL(N)*FMR - FUDIFX(IFC)
              !write(*,*) IFC, IJKUFc(3:7,IFC), ULCFLX(IFC), FUMD(IFC), &
              !           FUDIFX(IFC), M, N, TRANS1, TRANS2, FUTRN,     &
              !           FCNt(M), FCNt(N)
           ENDDO
!
!  Store conservative update and advective update
           DO ISEA=1,NSEA
              IF ( QTREE(IQGW)%CELL_TYPE(ISEA) .EQ. UNDEF ) CYCLE
              LVL = QTREE(IQGW)%INDLVL(ISEA)
              ! Inverse ratio squared of cell DX and DY to those at the 
              ! finest reference level
              DXYFAC = 4.**(LVL-LVLM)
              LVL = MAX(LVL,LVLT)
              IF ( LVL.NE.LVLCALC ) CYCLE
              CQA(ISEA) = CQ(ISEA) + FCNt(ISEA)*DXYFAC
              CQ (ISEA) = CQ(ISEA) + AFCN(ISEA)*DXYFAC
              FCNt(ISEA) = 0.0
              AFCN(ISEA) = 0.0
           END DO
!
!  Compute fluxes in y dimension:
!
           CALL QT1DUNO2( -9, IVF, JVF, IJKVFc(4:7,:), CQ, VCFL,       &
                          IJKCel(4,:), DSSD, IJKVFc(3,:), FMR, VLCFLY, &
                          FVMD, FVDIFY )
!
!  Store conservative flux
!
           DO IFC=ivf, jvf 
              M=IJKVFc(5,IFC)
              N=IJKVFc(6,IFC)
              TRANS1 = 1.
              IF (M.GT.0) TRANS1 = ATRNY(M,1)
              TRANS2 = 1.
              IF (N.GT.0) TRANS2 = ATRNY(N,-1)
              IF( VLCFLY(IFC) .GE. 0.0 )  THEN
                 FVTRN = (FVMD(IFC)*VLCFLY(IFC) - FVDIFY(IFC))*TRANS1
                 BCNt(M) = BCNt(M) - FVTRN
                 BCNt(N) = BCNt(N) + FVTRN*TRANS2 
              ELSE
                 FVTRN = (FVMD(IFC)*VLCFLY(IFC) - FVDIFY(IFC))*TRANS2
                 BCNt(M) = BCNt(M) - FVTRN*TRANS1
                 BCNt(N) = BCNt(N) + FVTRN 
              ENDIF
              !write(*,*) IFC, IJKVFc(3:7,IFC), VLCFLY(IFC), FVMD(IFC), &
              !           FVDIFY(IFC), M, N, TRANS1, TRANS2, FVTRN,     &
              !           BCNt(M), BCNt(N)
           ENDDO
           DO ISEA=1,NSEA
              IF ( QTREE(IQGW)%CELL_TYPE(ISEA) .EQ. UNDEF ) CYCLE
              LVL = QTREE(IQGW)%INDLVL(ISEA)
              ! Inverse ratio squared of cell DX and DY to those at the 
              ! finest reference level
              DXYFAC = 4.**(LVL-LVLM)
              LVL = MAX(LVL,LVLT)
              IF ( LVL.NE.LVLCALC ) CYCLE
              CQ(ISEA) = CQA(ISEA) + BCNt(ISEA)*DXYFAC
              BCNt(ISEA) = 0.0
           END DO
!
!
! 5.  Update boundary conditions ------------------------------------- *
!
          IF ( FLBPI ) THEN
            RD1    = DSEC21 ( TBPI0, TIME ) - DTG *                   &
                                   REAL(NTLOC - ITLOC)/REAL(NTLOC)
            RD2    = DSEC21 ( TBPI0, TBPIN )
            IF ( RD2 .GT. 0.001 ) THEN
              RD2    = MIN(1.,MAX(0.,RD1/RD2))
              RD1    = 1. - RD2
            ELSE
              RD1    = 0.
              RD2    = 1.
            END IF
            DO IBI=1, NBI
              ISEA = ISBPI(IBI)
              CQ(ISEA) = ( RD1*BBPI0(ISP,IBI) +                        &
                       RD2*BBPIN(ISP,IBI) ) * CLATS(ISEA)/CG(IK,ISEA)
            END DO
          END IF
!
! ... End of partial time substep loop
!
        END DO
!
! ... End of partial time step loop
!
      END DO
!
! Rescale FIELD
!
      DO ISEA=1,NSEA
        IF ( QTREE(IQGW)%CELL_TYPE(ISEA) .EQ. UNDEF ) CYCLE
        FIELD(ISEA) = CG(IK,ISEA) / CLATS(ISEA) * CQ(ISEA)
      END DO
!
      RETURN
!
! Formats
!
!/T 9000 FORMAT (' TEST W3XYQ2 : NTLOC :',I4)
!/T 9001 FORMAT (' TEST W3XYQ2 : ISP, ITH, IK :',I8,2I4)
!/T 9002 FORMAT (' TEST W3XYQ2 : LVLT, NTSUB :',2I4)
!
!/T1 9010 FORMAT (' TEST W3XYQ2 : ITLOC =',I3)
!
!/T1 9020 FORMAT (' TEST W3XYQ2 : ISEA, IXY, FIELD, VCX, VCY')
!/T1 9021 FORMAT ('           ',2I8,3E12.4)
!
!/
!/
!/ End of W3XYQ1 ----------------------------------------------------- /
!/
      END SUBROUTINE W3XYQ1
!      
!/ ------------------------------------------------------------------- /
!
      SUBROUTINE W3MPQ1 ( MAPSTA, LVRANGE )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH-III           NOAA/NCEP |
!/                  |           H. L. Tolman            |
!/                  | QUADTREE version             NIWA |
!/                  |           R. M. Gorman            |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         27-May-2014 |
!/                  +-----------------------------------+
!/
!/    29-May-2014 : Origination.
!/
!  1. Purpose :
!
!     Compute range of refinement levels for each cell and its
!     neighbours in a quadtree grid, prior to computing spatial propagation. 
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       MAPSTA  I.A.   I   Grid point status map.
!       LVRANGE I.A.   O   For each cell, gives the minimum and maximum
!                          refinement level of the cell and its immediate
!                          neighbours
!     ----------------------------------------------------------------
!
!     Local variables.
!     ----------------------------------------------------------------
!       NTLOC   Int.  Number of local steps.
!       VCX     R.A.  Propagation velocities.
!       VCY     R.A.
!       VFLX    R.A.  Discrete fluxes between grid points.
!       VFLY    R.A.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!      Name      Type  Module   Description
!     ---------------------------------------------------------------- 
!      W3WAVE    Subr. W3WAVEMD Wave model routine.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!       None.
!
!  7. Remarks :
!
!     - The local work arrays are initialized on the first entry to
!       the routine.
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
      USE QA_UTILS
!
      USE W3GDATMD, ONLY: NSEA, MAPSF, IQGW, QTREE
!/S      USE W3SERVMD, ONLY: STRACE
!/
      IMPLICIT NONE
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      INTEGER, INTENT(IN)     :: MAPSTA(NSEA)
      INTEGER, INTENT(OUT)    :: LVRANGE(NSEA,2)
!/
!/ ------------------------------------------------------------------ /
!/ Local parameters
!/
      INTEGER                 :: ISEA, IXY, LVL, II, INBR
!/
!/ ------------------------------------------------------------------- /
!/
!/S      CALL STRACE (IENT, 'W3MPQ1')
!
      DO ISEA=1,NSEA
         IXY = MAPSF(ISEA,3)
         IF ( MAPSTA(IXY).EQ.0 ) CYCLE
         LVL = QTREE(IQGW)%INDLVL(ISEA)
         LVRANGE(ISEA,1) = LVL
         LVRANGE(ISEA,2) = LVL
         DO II=1,4
            INBR = QTREE(IQGW)%NGBR(ISEA,II)
            IF ( INBR .GT. 0 ) THEN
               LVL = QTREE(IQGW)%INDLVL(INBR)
               LVRANGE(ISEA,1) = MIN(LVRANGE(ISEA,1),LVL)
               LVRANGE(ISEA,2) = MAX(LVRANGE(ISEA,2),LVL)
            END IF
         END DO
      END DO
!
      RETURN
!/
!/ End of W3MPQ1 ----------------------------------------------------- /
!/
      END SUBROUTINE W3MPQ1
!/
!/-------------------------------------------------------------------- /
!/
      SUBROUTINE QT1DUNO2( LBC, JWS, JWE, IJKFc, CF, UC, LEN_CELL,     &
                           AKDIF, WIDFC, FTS, UFLX, FU, FX )
!/
!/    Richard Gorman, NIWA
!/    19-Oct-2017 : Derived from SMCxUNO2, SMCyUNO2 (J-G Li).
!/
!  1. Purpose :
!
!     Compute mid-flux values for 1 dimension of propagation
!     under the UNO2 scheme
!
!  2. Method :
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       LBC       I    I   Lower bound for cell indices (to allow for
!                          indices <= 0 representing extra dummy cells)
!       JWS, JWE  I    I   First and last wall indices to compute
!       IJKFc    I.A.  I   Mapping from well index to indices of cells
!                          either side of the wall.
!                          Cells IJKFc(j,1-4) are successive in the +ve
!                          direction, with wall j between cells IJKFc(j,2)
!                          and IJKFc(j,3)
!       CF       R.A.  I   Tracer to be advected (at each cell centre)
!       UC       R.A.  I   Courant number (velocity component * DT/DX,
!                          where DT, DX are reference time and spatial
!                          increments) at each cell centre
!       LEN_CELL I.A.  I   Cell length (in the propagation dimension)
!                          relative to DX
!       AKDIF    R.A.  I   Diffusion coefficient*DT/(DX*DX) at each 
!                          cell centre
!       WIDFC    I.A.  I   Width (transverse to the propagation 
!                          dimension) for face, relative to a 
!                          reference spatial increment DY
!       FTS      Real  I   Time (sub)step relative to DT
!       UFLX     R.A.  I   Courant number at each wall 
!                          = velocity component * dt/DX,
!                          where dt, is the actual time (sub)step 
!       FU       R.A.  I   Mid flux value of tracer * actual wall width
!                          upstream from each wall 
!       FX       R.A.  I   Mid flux value of diffusive flux
!                          upstream from each wall 
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!      Name      Type  Module   Description
!     ---------------------------------------------------------------- 
!      W3XYQ2    Subr. W3PROQMD Quadtree UNO2 propagation with diffusion.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!       None.
!
!  7. Remarks :
!
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!
      IMPLICIT NONE
      INTEGER, INTENT( IN) :: LBC
      INTEGER, INTENT( IN) :: JWS, JWE
      INTEGER, INTENT( IN) :: IJKFc(:,:)
      REAL,    INTENT( IN) :: CF(LBC:), UC(LBC:)
      INTEGER, INTENT( IN) :: LEN_CELL(LBC:)
      REAL,    INTENT( IN) :: AKDIF(LBC:)
      INTEGER, INTENT( IN) :: WIDFC(:)
      REAL,    INTENT( IN) :: FTS
      REAL,    INTENT(OUT) :: UFLX(:), FU(:), FX(:)
!
      INTEGER :: JW, K, L, M, N, IU, IC, ID, IJ
      REAL :: DIFC_TS, CNWALL, LEN_U, LEN_C, LEN_D, LEN_W
      REAL :: GRAD_DC, GRAD_CU, GRAD_MIN
!
!    Two layer of boundary cells are added to each boundary cell face
!    with all boundary cell values CF(LBC:0)=0.0.

!    Notice an extra side length L is multiplied to mid-flux to give correct
!    proportion of flux into the cells.  This length will be removed by the
!    cell length when the tracer concentration is updated.

      !write(*,*) 'JW, IU, IC, ID, DIFC_TS, GRAD_DC, GRAD_CU, LEN_C,',  &
      !            ' LEN_D, LEN_W, CF(IU), CF(IC), CF(ID) CNWALL, CNST'
      DO JW=JWS,JWE

!    Select Upstream, Central and Downstream cells
         K=IJKFc(1,JW)
         L=IJKFc(2,JW)
         M=IJKFc(3,JW)
         N=IJKFc(4,JW)
!    Courant number at the wall arithmetic average, rescaled for
!    time step being a fraction FTS of the reference time step.
         CNWALL = 0.5*( UC(L)+UC(M) )*FTS
         IF(CNWALL >= 0.0)  THEN
           IU = K
           IC = L
           ID = M
         ELSE
           IU = N
           IC = M
           ID = L
         END IF
         UFLX(JW) = CNWALL
!
!    Use central cell velocity for boundary flux.  JGLi06Apr2011
         IF( ID .LE. 0) UFLX(JW) = UC(IC)*FTS

!    Face bounding cell lengths and (half of) central gradient
         LEN_C = MAX(LEN_CELL(IC),1) 
         LEN_D = MAX(LEN_CELL(ID),1) 
         GRAD_DC = (CF(ID)-CF(IC))/(LEN_C + LEN_D)


!    Length of the wall
         LEN_W = WIDFC(JW)

!    Diffusion Fourier no. at sub-time-step, proportional to face size,
!    which is also equal to the sub-time-step factor FTS.
!    The maximum cell number is used to avoid the boundary cell number
!    in selection of the cosine factor.
         IJ = MAX(IC, ID)
         !DIFC_TS = AKDif(IJ)*FTS   ?
         DIFC_TS = AKDif(IJ)*FTS*FTS

!    Upstream cell length and (half-)gradient
         LEN_U = MAX(LEN_CELL(IU),1)
         GRAD_CU = (CF(IC)-CF(IU))/(LEN_C + LEN_U)

!    Use minimum (half-)gradient all region.
         GRAD_MIN = SIGN(1.0, GRAD_DC)*MIN( ABS(GRAD_CU), ABS(GRAD_DC) )

!    Mid-flux value inside central cell
         FU(JW) = (CF(IC) + GRAD_MIN*(LEN_C - ABS(CNWALL)))*LEN_W
!    First order scheme:
!         FU(JW) = CF(IC)*LEN_W

!    Diffusion flux by face gradient x DT 
         FX(JW) = 2.0*DIFC_TS*GRAD_DC*LEN_W
         !write(*,*) JW, IU, IC, ID, DIFC_TS, GRAD_DC, GRAD_CU, LEN_C,  &
         !           LEN_D, LEN_W, CF(IU), CF(IC), CF(ID), CNWALL, CNST 
      END DO

      RETURN
      END SUBROUTINE QT1DUNO2

!/
!/ End of module W3PROQMD -------------------------------------------- /
!/
      END MODULE W3PROQMD
